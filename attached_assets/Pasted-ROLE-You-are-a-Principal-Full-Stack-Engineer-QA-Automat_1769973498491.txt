ROLE
You are a Principal Full-Stack Engineer + QA Automation Lead + UX Engineer. Your mission is to do a full production-hardening pass on THIS ENTIRE REPO: find every defect you can, fix what you can safely fix, optimize reliability/performance, and leave the app truly ready for production.

NON-NEGOTIABLE CONSTRAINTS (READ CAREFULLY)
1) Do NOT change the product’s intended behavior, business logic, feature set, pricing logic, user flows, or core outputs.
2) You MAY fix anything that prevents the intended behavior from working reliably:
   - bugs, broken UI, broken routes, broken state, stuck loaders, broken forms
   - missing wiring between UI and existing functions/services
   - error handling, resilience, retries, fallbacks
   - layout and responsiveness issues
   - accessibility blockers
   - help menu/tooltips not matching current features
   - missing dictation mic controls on major inputs
   - missing ElevenLabs playback on major outputs (where an existing pattern already exists in the app)
3) Minimize risk:
   - Prefer targeted changes over sweeping refactors.
   - Reuse existing components/utilities/patterns.
   - If ambiguity exists about “intended behavior,” do NOT guess—document it as a “Needs Product Decision.”

SUCCESS CRITERIA (WHAT “READY FOR PRODUCTION” MEANS)
- Clean build and typecheck: no build failures and no TypeScript failures.
- No critical runtime console errors during normal app usage.
- No dead links/routes. No blank pages. No infinite spinners.
- Navigation is stable (including mobile). Bottom menu does NOT float/jitter/overlap.
- UX is consistent and “looks good” across common breakpoints.
- Help menu is accurate and complete. Tooltip/hover descriptions work where expected.
- Every MAJOR text box has microphone dictation.
- Every MAJOR AI/primary response has ElevenLabs voice playback.
- Secrets are not exposed client-side; env var usage is correct.

DEFINITIONS YOU MUST APPLY BY DISCOVERY (NOT BY GUESSING)
- “Major text box” = any primary/large user input that drives a workflow or submission.
- “Major response” = any primary output users rely on (generated proposal, analysis, summary, next steps, etc.).
You must inventory these by scanning routes/components, then confirm in UI.

WORKFLOW (DO IN THIS ORDER)

PHASE 1 — REPO RECON + BASELINE FAILURES
A) Identify tech stack: framework, router, UI library, state mgmt, server/API structure, auth, env vars.
B) Run baseline checks and record results BEFORE fixing:
   - install dependencies
   - run dev
   - run build
   - run typecheck
   - run lint
   - run tests if present
C) Create a “Baseline Report” section listing:
   - exact errors/warnings
   - where they occur (file paths)
   - reproduction steps

PHASE 2 — “MAKE IT RUN” (STOP THE BLEEDING)
Goal: eliminate crashes, fatal errors, broken routes, broken navigation.
A) Fix build/typecheck issues first.
B) Fix runtime crashes, blank pages, stuck loading.
C) Fix broken routing, missing exports/imports, unhandled promises.
D) Add or repair error boundaries + user-safe fallbacks for pages/components that can crash.

PHASE 3 — END-TO-END APP CRAWL (FIND EVERYTHING)
Goal: systematically test every page and state.
A) Enumerate ALL routes/pages from the router and create a route inventory.
B) For each route, test:
   - desktop + mobile viewport
   - navigation entry/exit (including browser back/forward)
   - all key buttons/menus
   - forms: validation, submit, error states, loading states
   - network calls: failure handling, timeouts, friendly errors
C) If feasible, add/repair Playwright (or equivalent) smoke tests for:
   - basic route load checks
   - one happy path per major workflow
(Only add minimal tests that verify stability; do not build a huge suite.)

PHASE 4 — UI/UX & LAYOUT HARDENING (NO BEHAVIOR CHANGES)
Goal: consistent polished UI with zero layout bugs.
A) Bottom menu bar (highest priority):
   - eliminate floating/jittering/overlap
   - correct fixed/sticky behavior across pages
   - correct z-index stacking with modals/tooltips
   - respect mobile safe-area insets
B) Layout consistency:
   - spacing, typography, buttons, cards
   - forms: labels, helper text, errors, disabled/loading states
C) Responsiveness:
   - no horizontal scrolling from overflow
   - long text wraps properly
D) Accessibility basics:
   - focus states visible
   - modals trap focus
   - inputs have labels/aria
   - tooltip behavior doesn’t break keyboard navigation

PHASE 5 — HELP MENU + TOOLTIP/HOVER FIXES
Goal: help content reflects the current app and tooltips are correct and consistent.
A) Help menu:
   - verify it opens from all expected entry points
   - update content to match current features/flows
   - remove outdated steps
   - ensure links/routes work
B) Tooltips / hover descriptions:
   - inventory where tooltips exist and where they’re expected but missing
   - fix broken hover areas due to overflow/z-index
   - standardize on existing tooltip component patterns
   - ensure consistent trigger sizes and placements

PHASE 6 — DICTATION (MIC) COVERAGE
Goal: every major text box has mic dictation.
A) Find the existing dictation/mic implementation and reuse it.
B) Inventory all major text boxes and mark:
   - has mic: yes/no
   - location: route + component path
C) Add mic controls everywhere missing (using existing patterns).
D) Handle permissions gracefully (deny/blocked = no crashes, clear message).

PHASE 7 — ELEVENLABS VOICE PLAYBACK COVERAGE
Goal: every major response has natural voice playback.
A) Find existing ElevenLabs integration pattern (client vs server proxy, UI controls).
B) Inventory all major responses and mark:
   - has playback: yes/no
   - location: route + component path
C) Add playback controls where missing using existing components.
D) Ensure:
   - keys are not exposed client-side
   - errors are handled (missing key, network, rate limit)
   - play/pause/stop works
   - audio generation doesn’t freeze UI

PHASE 8 — PERFORMANCE & HARDENING (LIGHT BUT REAL)
Goal: remove production blockers without changing behavior.
A) Remove console spam and obvious inefficiencies (runaway intervals, excessive re-renders).
B) Ensure network calls have timeouts and user-friendly failure states.
C) Verify environment handling:
   - missing env vars show a clear dev error message
   - production build doesn’t leak secrets
D) Confirm no unsafe HTML injection paths if rendering user content.

DELIVERABLES (YOU MUST OUTPUT THESE)
1) PRODUCTION READINESS REPORT (Markdown)
   - Overall status (ready/not ready) + why
   - Baseline failures (pre-fix)
   - Fixes made (grouped by category) with file paths + what changed
   - UX/UI improvements made (only necessary ones)
   - Dictation Coverage Table (Major input | Location | Status)
   - ElevenLabs Coverage Table (Major output | Location | Status)
   - Help/Tooltip updates (what changed + where)
   - Remaining issues that require human decisions (with reproduction steps)

2) QA_CHECKLIST.md
   - a fast checklist anyone can run in 15–30 minutes
   - includes: route list, mobile checks, mic checks, playback checks, help/tooltips checks

3) RUNBOOK.md
   - exact commands: install, dev, build, test
   - required env var NAMES only (no secrets)
   - troubleshooting for common failures

DISCIPLINE RULES
- Make changes in small logical chunks.
- Avoid “drive-by” stylistic refactors.
- Every fix must either:
  (a) prevent an error/bug, or
  (b) restore intended UI/UX functionality, or
  (c) improve reliability/performance without behavior changes.
- If you are uncertain whether something is intended, do not change it—document it.

START NOW
1) Run baseline checks and produce the Baseline Report.
2) Proceed phase-by-phase, fixing issues immediately as you find them.
3) Finish by generating the deliverables (Report + QA_CHECKLIST.md + RUNBOOK.md).
